@namespace BlazorVirtualTreeView
@typeparam T
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization

<script>
    /**
     * Scrolls the virtualized tree container to the approximate index of a node.
     * This is a two-phase virtualization-safe scroll:
     *   1) Force the Virtualize component to render the target row by index.
     *   2) Adjust the scroll position to account for real-world DOM row height.
     *
     * This function does NOT guarantee pixel-perfect alignment on its own;
     * it ensures the target row exists in the DOM so a follow-up scroll
     * (by DOM id) can safely occur.
     */
    window.lazyTreeScrollToIndex = (container, index, rowHeight) => {

        /**
         * Locate the first rendered tree row currently in the DOM.
         * We use this row to determine the actual rendered row height.
         *
         * In virtualized lists, the configured row height is an estimate.
         * Fonts, padding, borders, and line-height can all cause the real
         * rendered height to differ slightly.
         */
        const firstRow = container.querySelector(".virt-tree-row");

        /**
         * Offset is critical to avoid cumulative scroll drift.
         *
         * If the actual DOM row height differs from the configured
         * Virtualize ItemSize, repeated index-based scrolling will
         * overshoot or undershoot the target position.
         *
         * We compute the delta once and apply it to the scroll calculation.
         */
        let offset = 0;

        if (firstRow) {
            const computedHeight = firstRow.getBoundingClientRect().height;
            offset = computedHeight - rowHeight;
        }

        /**
         * Scroll to the estimated vertical position for the target index.
         * This ensures the row is rendered by the virtualizer.
         */
        container.scrollTop = Math.max(0, index * (rowHeight + offset));
    };



     /**
      * Scrolls the tree to a specific node by DOM id.
      *
      * This function assumes the node may not yet exist in the DOM due to
      * virtualization. It retries using requestAnimationFrame until the
      * element appears or a maximum retry count is reached.
      *
      * This is the second phase of programmatic scrolling and is responsible
      * for precise positioning and visual centering.
      *
      * NOTE: Replaces the naive scrollIntoView behavior with an explicit
      * container.scrollTo-based centering step for more deterministic
      * alignment. After scrolling we verify and make small adjustments
      * on subsequent animation frames so intermittent race conditions
      * with virtualization / rendering are tolerated.
      */
    window.lazyTreeScrollToNode = (container, nodeId, smooth, align) => {
        let attempts = 0;
        const maxAttempts = 60; // allow extra frames for slow renders

        const computeAndScrollCenter = (node) => {
            const containerRect = container.getBoundingClientRect();
            const nodeRect = node.getBoundingClientRect();

            // Distance from container top to node top in document coordinates.
            const nodeTopInContainer = nodeRect.top - containerRect.top;

            // Desired scrollTop so the node's center aligns with container center.
            const targetScrollTop = Math.max(0,
                container.scrollTop + nodeTopInContainer - (containerRect.height / 2) + (nodeRect.height / 2));

            if (typeof container.scrollTo === "function") {
                try {
                    container.scrollTo({ top: targetScrollTop, behavior: smooth ? "smooth" : "auto" });
                } catch (e) {
                    // Some environments may throw for options — fallback to direct assignment.
                    container.scrollTop = targetScrollTop;
                }
            } else {
                container.scrollTop = targetScrollTop;
            }
        };

        const isCenteredEnough = (node) => {
            const containerRect = container.getBoundingClientRect();
            const nodeRect = node.getBoundingClientRect();

            const nodeCenter = nodeRect.top + nodeRect.height / 2;
            const containerCenter = containerRect.top + containerRect.height / 2;

            // Allow a small tolerance (few pixels) to account for subpixel/layout differences.
            return Math.abs(nodeCenter - containerCenter) <= 2;
        };

        const tryScroll = () => {
            const node = document.getElementById(nodeId);

            if (!node) {
                if (attempts++ < maxAttempts) {
                    requestAnimationFrame(tryScroll);
                }
                return;
            }

            // If consumer requested center alignment, perform a precise container-based center scroll
            if (align === "center") {
                computeAndScrollCenter(node);

                // Verify and adjust on subsequent frames if necessary.
                const verify = () => {
                    // If we are already centered, we're done.
                    if (isCenteredEnough(node))
                        return;

                    if (attempts++ < maxAttempts) {
                        // Recompute relative positions and nudge the scroll (non-smooth to avoid long animations).
                        computeAndScrollCenter(node);
                        requestAnimationFrame(verify);
                    }
                };

                // Start verification on next frame so DOM has a chance to settle.
                requestAnimationFrame(verify);
                return;
            }

            // For non-center alignment, fall back to scrollIntoView which honors 'start'/'nearest'.
            try {
                node.scrollIntoView({
                    behavior: smooth ? "smooth" : "auto",
                    block: align,
                });
            } catch (e) {
                // Older browsers may not support the options object; fallback to default scrollIntoView.
                try {
                    node.scrollIntoView();
                } catch (ignored) { }
            }
        };

        tryScroll();
    };



    /**
     * Ensures the node is fully visible inside the container, with a top padding.
     * Simplified for the single call site in this project: non-smooth keyboard scroll
     * and always called with a padTop value. Retries until the node exists or max attempts.
     */
    window.lazyTreeScrollEnsureTopVisible = (container, nodeId, padTop) => {
        let attempts = 0;
        const maxAttempts = 10;

        const tryEnsure = () => {
            const node = document.getElementById(nodeId);
            if (!node) {
                if (attempts++ < maxAttempts) {
                    requestAnimationFrame(tryEnsure);
                }
                return;
            }

            const containerRect = container.getBoundingClientRect();
            const nodeRect = node.getBoundingClientRect();

            // Already fully visible with padding
            if (nodeRect.top >= containerRect.top + padTop && nodeRect.bottom <= containerRect.bottom) {
                return;
            }

            // Node above container top + padTop -> scroll up to align top + pad
            if (nodeRect.top < containerRect.top + padTop) {
                const offset = nodeRect.top - containerRect.top - padTop;
                container.scrollTop += offset;
                return;
            }

            // Node bottom below container bottom -> scroll down to bring bottom into view
            if (nodeRect.bottom > containerRect.bottom) {
                const offset = nodeRect.bottom - containerRect.bottom;
                container.scrollTop += offset;
                return;
            }
        };

        tryEnsure();
    };

    /**
     * Instantly scrolls the tree container to the top.
     */
    window.lazyTreeScrollToTop = (container) => {
        if (container)
            container.scrollTop = 0;
    };

    /**
     * Focus the tree container element.
     * Called from .NET when selecting programmatically so keyboard navigation works.
     */
    window.lazyTreeFocus = (container) => {
        try {
            if (container && typeof container.focus === 'function') {
                container.focus();
            }
        } catch (e) {
            // swallow - focus is best-effort
        }
    };

</script>



@* 
    Scrollable container for the virtualized tree.
    - max-height is configurable via parameter
    - overflow-y enables independent scrolling
    - id is used by JS interop for programmatic scrolling
*@
<div @ref="_containerRef"
     id="lazy-virt-tree-container"
     class="virt-tree-container"
     style="height:@Height; overflow-y:auto; width:@Width"
     tabindex="0"
     @onkeydown="HandleKeyDown">

    @* 
        Virtualize renders only the visible subset of nodes for performance.
        - Items is the flattened list of expanded nodes
        - ItemSize must closely match the rendered row height
        - OverscanCount renders extra rows above/below for smooth scrolling
    *@
    <Virtualize Items="@_visibleNodes"
                Context="node"
                ItemSize="@RowHeight"
                OverscanCount="15">

        <ItemContent>
            @* 
                Single tree row.
                - DomId is required for scroll-to-node JS interop
                - Selected node is visually highlighted
                - Click selects the node
                - Right-click raises a context menu event
            *@
            <div id="@node.DomId"
                 class="virt-tree-row"
                 style="max-height:@(RowHeight)px;"
                 @oncontextmenu="@((MouseEventArgs e) => OnContextMenuAsync(e, node))"
                 @oncontextmenu:preventDefault="true"
                 @oncontextmenu:stopPropagation="true">

                @* Keep the indentation applied to the icon + content so alignment is preserved. *@
                <div style="display: flex; width: 100%;">
                    
                    @* Spacer for indentation *@
                    <div style="flex-shrink: 0; width: @(Math.Max(0, (ShowRootNode ? node.Level + 1 : node.Level)) * IndentSizePx)px;"></div>

                    <div class="virt-tree-main" style="height: 100%; flex: 1; min-width: 0; align-items: center;">

                        @* Expand / collapse toggle*@
                        @if (!node.IsLeafNode)
                        {
                            var expandIcon = ResolveExpandIcon(node);

                            if (!string.IsNullOrEmpty(expandIcon))
                            {
                                <div class="virt-tree-icon material-symbols-outlined @(node.IsLoading ? "virt-tree-spinner" : "")"
                                     style="font-size:@($"{IconSizePx}px"); font-weight: 400;"
                                     @onclick:stopPropagation="true"
                                     @onclick="@(() => ToggleAsync(node))">
                                    @expandIcon
                                </div>
                            }
                            else
                            {
                                @* Placeholder keeps text alignment consistent when there is no expand glyph *@
                                <div class="virt-tree-icon-placeholder"
                                     style="width:@($"{IconSizePx}px"); height:@($"{IconSizePx}px");">
                                </div>
                            }
                        }
                        else
                        {
                            @* Placeholder keeps text alignment consistent for leaf nodes *@
                            <div class="virt-tree-icon-placeholder"
                                 style="width:@($"{IconSizePx}px"); height:@($"{IconSizePx}px");">
                            </div>
                        }

                        @* 
                            Node content.
                        *@
                        <div class="virt-tree-content @(node == SelectedNode ? "selected" : "")" 
                             @onclick="@(() => OnRowClicked(node))"
                             @ondblclick="@(() => OnRowDoubleClicked(node))">

                            @if (NodeTemplate != null)
                            {
                                @NodeTemplate(node)
                            }
                            else
                            {
                                <!-- DEFAULT RENDERING -->

                                @* Main node icon (consumer-defined) *@
                                <div class="virt-tree-node-icon material-symbols-outlined"
                                        style="font-size:@($"{IconSizePx}px"); font-weight: 400; margin-right: 8px;">
                                    @ResolveNodeIcon(node)
                                </div>

                                @* Display text for the node (no flex) *@
                                <div class="virt-tree-text"
                                        style="font-size:@($"{FontSizePx}px"); font-weight: 400;">
                                    @node.Text
                                </div>

                            }

                    

                        </div>
                    </div>

                </div>
            </div>
        </ItemContent>

    </Virtualize>

</div>