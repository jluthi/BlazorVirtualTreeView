@page "/"
@rendermode InteractiveServer

@using BlazorVirtualTreeView
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms

@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject NotificationService NotificationService
@inject ContextMenuService ContextMenuService

<PageTitle>Virtual Tree View Demo</PageTitle>

@*
    Home page for the Virtual Tree View demo.
    Presents controls to interact with a virtualized, lazy-loaded tree component
    and demonstrates features such as selection, navigation, context menus, URL synchronization, and more...
*@

<div style="width:50%">
    <h3>Blazor <strong>Virtual</strong> Tree View (+ Lazy Loading) Demo</h3>

    <p>
        This demo showcases a <strong>virtual tree view</strong> where the full
        hierarchy is known in advance, but individual nodes are only created when
        they are expanded <strong>(lazy loaded)</strong>.
    </p>

    <p>
        To simulate real-world scale, the tree can represent thousands of deeply
        nested nodes. However, only the rows that are currently visible in the
        viewport exist in the <strong>HTML DOM</strong> at any given time.
        As you scroll, nodes dynamically <em>enter</em> the DOM when they come
        into view and <em>leave</em> the DOM when they scroll out of view.
        This minimizes DOM size, reduces layout and rendering cost, and enables
        smooth, high-performance scrolling even with very large data sets
        <strong>(virtualization)</strong>.
    </p>

</div>



<div class="m-3 d-flex flex-column gap-2" style="width: fit-content;">

    <!-- Navigation -->
    <div class="d-flex align-items-center gap-2">
        <span class="text-muted fw-semibold me-2">Navigation</span>

        <RadzenButton Text="Go To Random Node"
                      Icon="casino"
                      ButtonStyle="ButtonStyle.Primary"
                      Click="GoToDeepNode"
                      title="Navigates to a random deeply nested node." />

        <RadzenButton Text="Go To Selected"
                      Icon="my_location"
                      ButtonStyle="ButtonStyle.Light"
                      Click="GoToSelectedNode"
                      Disabled="_treeView?.SelectedNode == null"
                      title="Scrolls to the currently selected node." />

        <RadzenButton Text="Refresh Page"
                      Icon="refresh"
                      ButtonStyle="ButtonStyle.Light"
                      Click="@(() => NavigationManager.NavigateTo(NavigationManager.Uri, forceLoad: true))"
                      title="Reloads the page according to the current URL state." />

        <RadzenCheckBox @bind-Value="_syncSelectionToUrl"
                        TValue="bool"
                        Change="OnUrlSyncToggled"
                        Style="margin-left:12px;" />

        <span class="text-muted">Sync URL to Selection</span>
    </div>

    <!-- Actions: Collapse / Clear / Reset -->
    <div class="d-flex align-items-center gap-2">
        <span class="text-muted fw-semibold me-2">Actions</span>

        <RadzenButton Text="Collapse All"
                      Icon="expand_less"
                      ButtonStyle="ButtonStyle.Light"
                      Click="CollapseAll"
                      title="Collapses all expanded nodes." />

        <RadzenButton Text="Clear Selection"
                      Icon="mop"
                      ButtonStyle="ButtonStyle.Light"
                      Click="ClearSelection"
                      Disabled="_treeView?.SelectedNode == null"
                      title="Clears the current selection highlight." />

        <RadzenButton Text="Reset to Default"
                      Icon="restart_alt"
                      ButtonStyle="ButtonStyle.Secondary"
                      Click="ResetToDefaultsAsync"
                      title="Reset controls and persisted settings to their defaults." />
    </div>

    <!-- Properties -->
    <div class="d-flex align-items-center gap-2">
        <span class="text-muted fw-semibold me-2">Component Properties</span>

        <RadzenCheckBox @bind-Value="_showRootNode"
                        TValue="bool"
                        Change="OnShowRootNodeChanged"
                        Style="margin-left:12px;"
                        title="Show or hide the implicit root node."
                        aria-label="Show Root Node" />

        <span class="text-muted">Show Root Node</span>

        <RadzenCheckBox @bind-Value="_expandOnDoubleClick"
                        TValue="bool"
                        Change="OnExpandOnDoubleClickChanged"
                        Style="margin-left:12px;"
                        title="Enable to expand/collapse nodes by double-clicking them."
                        aria-label="Expand on Double Click" />

        <span class="text-muted">Expand on Double Click</span>

        <RadzenCheckBox @bind-Value="_disableSmoothScroll"
                        TValue="bool"
                        Change="OnDisableSmoothScrollChanged"
                        Style="margin-left:12px;"
                        title="Disable animated smooth scrolling when navigating to or selecting a node. When checked, scrolling is instantaneous."
                        aria-label="Disable Smooth Scrolling" />

        <span class="text-muted">Disable Smooth Scrolling</span>

        <span class="text-muted" style="margin-left:12px;">Auto Scroll Alignment</span>

        <InputSelect @bind-Value="_scrollAlignment"
                     class="form-select"
                     style="width:160px;margin-left:6px;"
                     title="Determines where the target node will be placed in the viewport when scrolled into view."
                     aria-label="Scroll Alignment"
                     @onchange="OnScrollAlignmentChanged">
            @foreach (var s in Enum.GetValues(typeof(ScrollAlignments)).Cast<ScrollAlignments>())
            {
                <option value="@s">@s</option>
            }
        </InputSelect>
    </div>

    <div class="d-grid" style="grid-template-columns: 165px auto; ">
         <span class="text-muted">Lazy Load Delay</span>

        <!-- Load delay -->
        <div class="d-flex align-items-center gap-2">
            <RadzenSlider @bind-Value="_loadDelayMs"
                          TValue="int"
                          Change="OnLoadDelayMsChanged"
                          Min="0"
                          Max="10000"
                          Step="100"
                          Style="width:350px"
                          title="Adjusts simulated latency when loading child nodes" />

            <span class="text-muted small">@_loadDelayMs ms</span>
        </div>

        <!-- Lazy load node count -->
        <span class="text-muted">Loaded Nodes (count): </span>

        <span class="text-muted">@TotalLoadedNodeCount</span>
    </div>

    <hr/>

</div>



@*VIRTUALIZED TREE VIEW CODE IS HERE!*@
@* Note: This demo uses string as T (type). Replace T with your domain model and
   update the LoadChildrenAsync signature accordingly (or whatever your equivalent method will be called). *@
<VirtualTreeView @ref="_treeView"
                 Height="800px"
                 Width="30%"
                 T="string"
                 Roots="@Roots"
                 LoadChildren="LoadChildrenAsync"
                 ShowRootNode="@_showRootNode"
                 Size="VirtualTreeViewSize.Medium"
                 DisableSmoothScrolling="@_disableSmoothScroll"
                 AutoScrollAlignment="@_scrollAlignment"
                 ExpandNodeOnDoubleClick="@_expandOnDoubleClick"
                 SelectedNodeChanged="OnSelectedNodeChanged"
                 OnNodeContextMenu="OnNodeContextMenu">

    @* Optional: Provide a custom per-node template to tailor the node look and feel to your needs. Uncomment the code below for an example. 
       - Context: `node` is a `VirtualTreeViewNode<T>` (here `T = string` is defined above, but normally you would use whatever custom object model you wish to bind to).
       - Available public properties on `VirtualTreeViewNode<T>`:
           - `string DomId { get; }`                — stable DOM id for virtualization/scroll targeting
           - `string Path { get; init; }`           — hierarchical path (e.g. "a/b/c")
           - `T Value { get; init; }`               — user-defined domain object bound to the node
           - `string Text { get; set; }`            — display text shown in the tree
           - `VirtualTreeViewNode<T>? Parent { get; internal set; }` — parent reference
           - `int Level { get; internal set; }`     — depth level in the tree (root = 0)
           - `bool IsLeafNode { get; set; }`        — whether this node can have children or not. Leaf nodes do not.
           - `bool IsExpanded { get; internal set; }` — whether the node is currently expanded
           - `List<VirtualTreeViewNode<T>>? Children { get; internal set; }` — lazily-loaded children (null = not loaded yet)
           - `string CollapsedIcon { get; set; }`   — icon used when collapsed
           - `string ExpandedIcon { get; set; }`    — icon used when expanded
           - `string LeafIcon { get; set; }`        — icon used for leaf nodes

       Notes:
       - `Children == null` typically means children are not yet loaded; an empty list means no children.
       - Templates are created/destroyed frequently due to virtualization — keep markup simple and avoid heavy work.
    *@
        
@*Uncomment below to see custom node template example*@
@*     <NodeTemplate Context="node">
        <div style="display:flex;align-items:center;gap:8px;">
            <!-- Icon -->
            <div class="material-symbols-outlined" style="font-size:20px;">
                @(node.IsLeafNode ? node.LeafIcon : (node.IsExpanded ? node.ExpandedIcon : node.CollapsedIcon))
            </div>

            <!-- Text -->
            <div>
                @node.Text
            </div>

            <!--Custom Display Counter-->
            <span>
                (@(node.Children == null ? "?" : node.Children.Count.ToString()))
            </span>
        </div>
    </NodeTemplate>  *@ 
   

</VirtualTreeView>

@code
{
    #region Demo Node Generation Constants

    // Parameters used to generate the demo tree structure.
    private const int RootCount = 50;
    private const int MaxDepth = 6;
    private const int ChildrenPerNode = 1000;

    // Controls how many nodes per level can be folders (can have children)
    // vs. leaf-only nodes (files).
    private const int ChildrenCapablePerLevel = 600; // folders
    private const int LeafOnlyPerLevel = 400;        // files

    #endregion



    #region State

    // Shared random instance for demo behaviors.
    private static readonly Random _rand = Random.Shared;

    // Reference to the VirtualTreeView component instance so we can call API methods.
    private VirtualTreeView<string>? _treeView;
    private VirtualTreeViewNode<string>? _selectedNode;

    // Roots provided to the component. Generated on initialization.
    private IReadOnlyList<VirtualTreeViewNode<string>> Roots = Array.Empty<VirtualTreeViewNode<string>>();

    // UI state flags
    private bool _syncSelectionToUrl = false;
    private bool _showRootNode = false;
    private bool _expandOnDoubleClick = false;
    private bool _disableSmoothScroll = false;

    // Scroll alignment used by the VirtualTreeView
    private ScrollAlignments _scrollAlignment = ScrollAlignments.Top;

    // Simulated load delay in milliseconds for lazy loading children
    private int _loadDelayMs = 200;
    private bool _handledInitialNavigation;

    // Track total loaded node count for demo
    private int TotalLoadedNodeCount = 0;

    #endregion


    #region Page Lifecycle

    /// <summary>
    /// Generate the initial root nodes when the component initializes.
    /// </summary>
    protected override void OnInitialized()
    {
        Roots = GenerateNodes(parentPath: "", depth: 0, count: RootCount);
    }

    /// <summary>
    /// After first render, load persisted UI settings and then check the query string for a node path and select it.
    /// This demonstrates syncing selection from the URL into the component.
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _handledInitialNavigation)
            return;

        _handledInitialNavigation = true;

        // Load persisted UI settings from localStorage (if present).
        await LoadSettingsAsync();

        var uri = new Uri(NavigationManager.Uri);
        var query = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);

        if (!query.TryGetValue("node", out var values))
            return;

        var path = values.FirstOrDefault();
        if (string.IsNullOrWhiteSpace(path))
            return;

        // Yield so any pending UI work can complete before selecting.
        await Task.Yield();

        await _treeView?.SelectNodeAsync(Uri.UnescapeDataString(path))!;
    }

    #endregion


    #region Tree Loading

    /// <summary>
    /// Callback used by the VirtualTreeView to lazily load children for a node.
    /// </summary>
    private async Task<IReadOnlyList<VirtualTreeViewNode<string>>> LoadChildrenAsync(
        VirtualTreeViewNode<string> parent)
    {
        // NOTE:
        // In a real application, your data access logic (API call, database query,
        // file system lookup, etc.) would typically live here.
        // All code below exists purely to simulate latency and generate demo data.

        // NOTE 2: There is no sort applied in the VirtualTreeView internally; if you need sorted nodes,
        // apply sorting in your LoadChildrenAsync implementation before returning.

        // Simulate asynchronous data retrieval to mimic real-world latency
        // (e.g., network or database access).
        if (_loadDelayMs > 0)
            await Task.Delay(_loadDelayMs);

        // Stop generating children once the maximum configured depth is reached.
        // Returning an empty collection marks this node as a leaf.
        if (parent.Level >= MaxDepth)
            return Array.Empty<VirtualTreeViewNode<string>>();

        // Generate the next level of children. The depth is incremented so that
        // node names and paths accurately reflect their position in the hierarchy.
        return GenerateNodes(
            parent.Path,
            parent.Level + 1,
            ChildrenPerNode);

    }

    /// <summary>
    /// Generates a list of nodes for a given parent path and depth.
    /// This demo creates a mixture of "folders" (nodes that can have children)
    /// and leaf nodes (files) based on configured caps per level.
    /// Also updates the demo-wide TotalLoadedNodeCount whenever nodes are created.
    /// </summary>
    private IReadOnlyList<VirtualTreeViewNode<string>> GenerateNodes(
        string parentPath,
        int depth,
        int count)
    {
        var list = new List<VirtualTreeViewNode<string>>(count);

        int folderCount = Math.Min(ChildrenCapablePerLevel, count);
        int leafCount = Math.Min(LeafOnlyPerLevel, count - folderCount);

        int index = 0;

        for (int i = 0; i < folderCount; i++, index++)
            list.Add(CreateNode(parentPath, depth, index, canHaveChildren: true));

        for (int i = 0; i < leafCount; i++, index++)
            list.Add(CreateNode(parentPath, depth, index, canHaveChildren: false));

        // Update the running total of nodes created for demo telemetry.
        System.Threading.Interlocked.Add(ref TotalLoadedNodeCount, list.Count);

        return list;
    }

    /// <summary>
    /// Creates an individual VirtualTreeViewNode with path and metadata.
    /// </summary>
    private VirtualTreeViewNode<string> CreateNode(
        string parentPath,
        int depth,
        int index,
        bool canHaveChildren)
    {
        var name = canHaveChildren
            ? $"D{depth}_N{index}"
            : $"D{depth}_N{index}.example";

        var node = new VirtualTreeViewNode<string>
        {
            Value = name,
            Text = name,
            Path = string.IsNullOrEmpty(parentPath) ? name : $"{parentPath}/{name}",
            IsLeafNode = !canHaveChildren
        };

        // Optional if you want to set custom icons per node.
        if (canHaveChildren)
        {
            // Use default icons
            node.CollapsedIcon = node.CollapsedIcon;
            node.ExpandedIcon = node.ExpandedIcon;
        }
        else
        {
            // Use default icon
            // Note: You can have the leaf icon be a different icon based on file type, etc., if desired.
            node.LeafIcon = node.LeafIcon;
      
        }

        return node;
    }

    #endregion

    #region Selection / Navigation

    /// <summary>
    /// Handler invoked when the currently selected node changes in the component.
    /// If URL sync is enabled, update the query string to reflect the selected node.
    /// </summary>
    private Task OnSelectedNodeChanged(VirtualTreeViewNode<string>? node)
    {
        _selectedNode = node;

        if (_syncSelectionToUrl && node != null)
        {
            var encoded = Uri.EscapeDataString(node.Path);
            NavigationManager.NavigateTo($"{NavigationManager.BaseUri}?node={encoded}", replace: true);
        }

        return Task.CompletedTask;
    }

    /// <summary>
    /// Scrolls to and selects the currently selected node (if any).
    /// </summary>
    private async Task GoToSelectedNode()
    {
        if (_treeView?.SelectedNode != null)
            await _treeView.SelectNodeAsync(_treeView.SelectedNode.Path);
    }

    /// <summary>
    /// Picks a random deep path and selects it to demonstrate programmatic navigation.
    /// </summary>
    private async Task GoToDeepNode()
    {
        if (_treeView == null)
            return;

        await _treeView.SelectNodeAsync(GenerateRandomDeepPath());
    }

    /// <summary>
    /// Generate a pseudo-random path into the tree using the same naming scheme
    /// as nodes generated by this demo.
    /// </summary>
    private string GenerateRandomDeepPath()
    {
        int targetDepth = Random.Shared.Next(MaxDepth / 2, MaxDepth);
        var segments = new List<string>(targetDepth + 1);

        for (int d = 0; d <= targetDepth; d++)
        {
            int maxIndex = d == 0
                ? RootCount                          // roots are all expandable
                : ChildrenCapablePerLevel;           // ONLY folders

            int index = Random.Shared.Next(0, maxIndex);

            segments.Add($"D{d}_N{index}");
        }

        return string.Join('/', segments);
    }


    private void CollapseAll() => _treeView?.CollapseAll();
    private void ClearSelection() => _treeView?.ClearSelection();

    /// <summary>
    /// Handle toggling URL sync. When disabled the query string is cleared.
    /// Persist the setting to localStorage so it survives refresh.
    /// </summary>
    private async Task OnUrlSyncToggled(bool value)
    {
        _syncSelectionToUrl = value;

        // Persist
        await SaveSettingAsync("bvtv_syncSelectionToUrl", value.ToString());

        if (!value)
            NavigationManager.NavigateTo(NavigationManager.BaseUri, replace: true);
    }

    #endregion


    #region Context Menu Actions

    /// <summary>
    /// Demonstrates opening a context menu for a node. Uses <see cref="ContextMenuService"/>.
    /// The menu provides actions such as copying path, refreshing, adding and deleting nodes.
    /// </summary>
    private Task OnNodeContextMenu(
        (MouseEventArgs MouseArgs, VirtualTreeViewNode<string> Node) args)
    {
        ContextMenuService.Open(args.MouseArgs, ds =>
        @<RadzenMenu>
            <RadzenMenuItem Text="Copy Path" Icon="content_copy" Click="@(() => CopyPath(args.Node))" />
            <RadzenMenuItem Text="Refresh" Icon="refresh" Click="@(() => RefreshNode(args.Node))" />
            <RadzenMenuItem Text="Add Child" Icon="add" Click="@(() => AddChild(args.Node))" />
            <RadzenMenuItem Text="Delete"
                            Icon="delete"
                            Disabled="@(args.Node != _treeView?.SelectedNode)"
                            Click="DeleteSelected" />
        </RadzenMenu>);

        return Task.CompletedTask;
    }

    /// <summary>
    /// Copies a link containing the node path to the clipboard and shows a notification.
    /// </summary>
    private async Task CopyPath(VirtualTreeViewNode<string> node)
    {
        var url = $"{NavigationManager.BaseUri}?node={Uri.EscapeDataString(node.Path)}";
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", url);

        NotificationService.Notify(
            NotificationSeverity.Success,
            "Node Path Copied",
            url,
            4000);

        ContextMenuService.Close();
    }

    /// <summary>
    /// Refreshes the currently selected node by reloading its children from the source.
    /// Ensures the node is selected first if it isn't already.
    /// </summary>
    private async Task RefreshNode(VirtualTreeViewNode<string> node)
    {
        if (_treeView == null)
            return;

        if (_treeView.SelectedNode != node)
            await _treeView.SelectNodeAsync(node.Path);

        await _treeView.RefreshSelectedAsync();
        ContextMenuService.Close();
    }

    /// <summary>
    /// Adds a new child under the provided parent node. The demo assigns a random
    /// "folder" vs "file" behavior to the new node.
    /// </summary>
    private void AddChild(VirtualTreeViewNode<string> parent)
    {
        if (_treeView == null)
            return;

        bool canHaveChildren = _rand.Next(0, 10) < 6;
        var name = $"New_{DateTime.Now:HHmmss}" + (canHaveChildren ? "" : ".example");

        var node = new VirtualTreeViewNode<string>
        {
            Value = name,
            Text = name,
            Path = $"{parent.Path}/{name}",
            IsLeafNode = !canHaveChildren
        };

        // Optional if you want to set custom icons per node.
        if (canHaveChildren)
        {
            // Use default icons
            node.CollapsedIcon = node.CollapsedIcon;
            node.ExpandedIcon = node.ExpandedIcon;
        }
        else
        {
            // Use default icon
            // Note: You can have the leaf icon be a different icon based on file type, etc., if desired.
            node.LeafIcon = node.LeafIcon;

        }

        _treeView.AddNode(node, _treeView.SelectedNode);

        // Keep demo counter in sync with manual additions.
        System.Threading.Interlocked.Increment(ref TotalLoadedNodeCount);

        ContextMenuService.Close();
    }

    /// <summary>
    /// Deletes the currently selected node via the component API.
    /// Note: the demo counter assumes a single node removed; if children are
    /// removed as well the counter will be an approximation.
    /// </summary>
    private void DeleteSelected()
    {
        if (_selectedNode != null)
        {
            _treeView?.RemoveNode(_selectedNode.Parent);
            System.Threading.Interlocked.Decrement(ref TotalLoadedNodeCount);
        }

        ContextMenuService.Close();
    }

    #endregion

    #region Persisted UI Settings (localStorage)

    private async Task OnShowRootNodeChanged(bool value)
    {
        _showRootNode = value;
        await SaveSettingAsync("bvtv_showRootNode", value.ToString());
    }

    private async Task OnExpandOnDoubleClickChanged(bool value)
    {
        _expandOnDoubleClick = value;
        await SaveSettingAsync("bvtv_expandOnDoubleClick", value.ToString());
    }

    private async Task OnDisableSmoothScrollChanged(bool value)
    {
        _disableSmoothScroll = value;
        await SaveSettingAsync("bvtv_disableSmoothScroll", value.ToString());
    }

    private async Task OnScrollAlignmentChanged(ChangeEventArgs e)
    {
        var raw = e?.Value?.ToString();
        if (!string.IsNullOrWhiteSpace(raw) && Enum.TryParse<ScrollAlignments>(raw, out var parsed))
        {
            _scrollAlignment = parsed;
            await SaveSettingAsync("bvtv_scrollAlignment", parsed.ToString());
            StateHasChanged();
        }
    }

    // Persist the load delay slider when it changes so it's restored on refresh.
    private async Task OnLoadDelayMsChanged(int value)
    {
        _loadDelayMs = value;
        await SaveSettingAsync("bvtv_loadDelayMs", value.ToString());
    }

    private async Task SaveSettingAsync(string key, string value)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", key, value);
        }
        catch
        {
            // Swallow exceptions on servers where localStorage is unavailable; this is a demo.
        }
    }

    private async Task LoadSettingsAsync()
    {
        try
        {
            var v1 = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "bvtv_showRootNode");
            if (bool.TryParse(v1, out var b1))
                _showRootNode = b1;

            var v2 = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "bvtv_expandOnDoubleClick");
            if (bool.TryParse(v2, out var b2))
                _expandOnDoubleClick = b2;

            var v3 = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "bvtv_disableSmoothScroll");
            if (bool.TryParse(v3, out var b3))
                _disableSmoothScroll = b3;

            var v4 = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "bvtv_syncSelectionToUrl");
            if (bool.TryParse(v4, out var b4))
                _syncSelectionToUrl = b4;

            var sa = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "bvtv_scrollAlignment");
            if (!string.IsNullOrWhiteSpace(sa) && Enum.TryParse<ScrollAlignments>(sa, out var parsed))
                _scrollAlignment = parsed;

            // Restore persisted load delay (ms) for the latency slider
            var ld = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "bvtv_loadDelayMs");
            if (int.TryParse(ld, out var parsedMs))
                _loadDelayMs = parsedMs;

            StateHasChanged();
        }
        catch
        {
            // localStorage may not be available in some contexts; ignore and continue.
        }
    }

    /// <summary>
    /// Removes persisted settings and resets in-memory values to their defaults.
    /// Navigates to base URI (clears query string) and notifies the user.
    /// </summary>
    private async Task ResetToDefaultsAsync()
    {
        try
        {
            // Remove persisted keys
            var keys = new[]
            {
                "bvtv_showRootNode",
                "bvtv_expandOnDoubleClick",
                "bvtv_disableSmoothScroll",
                "bvtv_syncSelectionToUrl",
                "bvtv_scrollAlignment",
                "bvtv_loadDelayMs"
            };

            foreach (var k in keys)
                await JSRuntime.InvokeVoidAsync("localStorage.removeItem", k);
        }
        catch
        {
            // Ignore localStorage errors in demo environments
        }


        NavigationManager.NavigateTo(NavigationManager.BaseUri, forceLoad: true);

    }

    #endregion
}
